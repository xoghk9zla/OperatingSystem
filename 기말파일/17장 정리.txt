***운영체제 17장 빈 공간 관리(ppt 128~)***
***분할 병합 내용이해, 할당 기법 숙지(특히 개별리스트, 버디할당)***

먼저, 빈 공간 리스트를 관리하고 있다는 것을 알아야한다.
빈 공간에 대한 정보(주소값과 빈 공간의 크기)가 리스트로 나열되어있다.


**분할(ppt 130)
malloc을 통해서 메모리를 1바이트 할당을 한다고 가정하면,
빈 공간의 크기 >= 1 임을 충족하는 리스트값을 찾아내어

주소값 += 할당할 크기 , 빈 공간의 크기 -= 할당할 크기

로 빈 공간을 업데이트 한다.


**병합(ppt 131)
메모리를 반환(free)한다고 가정하면,
해당 메모리의 주소값과 인접해있는 빈 청크의 주소값을 비교하여,
인접 할 경우 합한다.


**헤더 공간(ppt 132~134)
malloc으로 메모리를 할당하게 되면, 할당할 메모리 크기, 매직넘버 같은 정보를 저장할
헤더 공간을 추가로 할당해주게 된다.
free를 할때, 이 헤더공간을 참조해 매직넘버로 안전성을 검사한다.
(헤더공간은 보통 할당된 공간 바로 앞에 존재한다.)

**할당, 할당 해제 과정(ppt138~)

**힙 확장(ppt 142)
할당 가능 공간을 모두 소진하면, 운영체제로부터 더 많은 메모리를 요청한다.
이후 확장된 영역에서 새로운 청크를 할당한다.


**할당 기법(ppt 143~)
최적적합 - 빈 공간 리스트 중 할당할 공간의 크기와 비교해서 같거나 더 큰 청크를 찾는다.
	   이 후보들 중에서 가장 작은 크기의 청크를 반환한다.
           하지만, 할당할때마다 전체 빈 공간들을 검색해야하므로, 비용이 크다.

최악적합 - 빈 공간 리스트 중 할당할 공간의 크기와 비교해서 같거나 더 큰 청크를 찾는다.
	   이 기법은 항상 커다란 빈 청크를 남기려고 시도한다.
           자잘한 청크들을 만들지 않으려고 노력한다.
           하지만, 할당할때마다 전체 빈 공간들을 검색해야하므로, 비용이 크다.

최초적합 - 요청보다 큰 청크를 찾아서, 가장 최초로 찾은 주소값을 반환한다.
           빠른것이 장점이지만, 리스트 시작에 크기가 자잘한 청크가 많이 생겨날 수 있다.
           따라서 리스트를 주소로 정렬하여 병합을 쉽게하고 단편화도 감소시킨다.

다음적합 - 항상 리스트의 처음부터 시작하지만, 다음 적합 알고리즘은 마지막으로 찾았던 원	   	   소를 가리키는 포인터를 유지한다. 빈 공간 탐색을 리스트 전체에 균등하게 분산	           시킨다. 따라서 최초적합처럼 단편이 한 부분에 집중적으로 발생하지는 않는다.

개별 리스트 - 프로그램이 자주 요청하는 할당 크기들을 미리 리스트로 유지하고, 
           그 리스트에 대한 메모리 청크를 미리 준비한다.
	   리스트에 없는 할당 크기는 일반적인 할당으로 처리한다.
           장점은 특정 크기에 대한 작업을 미리 준비함으로써, 속도가 빠르지만,
           단점은 지정된 크기의 메모리, 일반적인 메모리를 얼마만큼 할당해야하는지도 문	    제이다.

버디 할당 - 합병을 보다 간단히 하기위해 사용하는 방법
            좋은 예로 '이진 버디 할당기'가 있다.
            자세한 내용은 ppt 154 참조